-------------------------------------------------------

泛型：
	jdk1.5出现的安全机制。
	
好处：
	1，将运行时期的问题ClassCastException转到了编译时期。
	2，避免了强制转换的麻烦。
	
<>:什么时候用？		当操作的引用数据类型不确定的时候。就使用<>。将要操作的引用数据类型传入即可.
   其实<>就是一个用于接收具体引用数据类型的参数范围。
   
在程序中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型 。

泛型技术是给编译器使用的技术,用于编译时期。确保了类型的安全。

运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。
为什么擦除呢？因为为了兼容运行的类加载器。

泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。


泛型的通配符：? 未知类型。 

泛型的限定：
? extends E: 接收E类型或者E的子类型对象。上限
一般存储对象的时候用。比如 添加元素 addAll.

? super E: 接收E类型或者E的父类型对象。 下限。
一般取出对象的时候用。比如比较器。

===========================================================

集合的一些技巧：

需要唯一吗？
需要：Set
	需要指定顺序： 
			需要： TreeSet
			不需要：HashSet
			但是想要一个和存储一致的顺序(有序):LinkedHashSet
不需要：List
	需要频繁增删吗？
		需要：LinkedList
		不需要：ArrayList
		
如何记住每一个容器的结构和所属体系呢？

看名字！


List
	|--ArrayList
	|--LinkedList

Set
	|--HashSet
	|--TreeSet

后缀名就是该集合所属的体系。

前缀名就是该集合的数据结构。

看到array：就要想到数组，就要想到查询快，有角标.	
看到link：就要想到链表，就要想到增删快，就要想要 add get remove+frist last的方法 
看到hash:就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。 
看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable，Comparator 。

而且通常这些常用的集合容器都是不同步的。 


============================================

Map：一次添加一对元素。Collection 一次添加一个元素。
	Map也称为双列集合，Collection集合称为单列集合。
	其实map集合中存储的就是键值对。 
	map集合中必须保证键的唯一性。 
	
	
常用方法：
1，添加。
	value put(key,value):返回前一个和key关联的值，如果没有返回null.

2，删除。
	void  clear():清空map集合。
	value remove(key):根据指定的key翻出这个键值对。 

3，判断。
	boolean containsKey(key):
	boolean containsValue(value):
	boolean isEmpty();

4，获取。 
	value get(key):通过键获取值，如果没有该键返回null。
					当然可以通过返回null，来判断是否包含指定键。 
	int size(): 获取键值对的个数。 
	
						
	
Map常用的子类：
	|--Hashtable :内部结构是哈希表，是同步的。不允许null作为键，null作为值。
		|--Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。 		
	|--HashMap : 内部结构是哈希表，不是同步的。允许null作为键，null作为值。
	|--TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 
	
	